package org.ssh.ipc.peripheral;

import com.google.common.collect.ImmutableSet;
import com.studiohartman.jamepad.*;
import java.util.*;
import java.util.function.Function;
import java.util.stream.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.reactivestreams.*;
import org.ssh.game.*;
import org.ssh.game.engine.*;
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

/**
 * The Class ControllerEngine.
 *
 * @param <A> The type of {@link Agent} which is being controlled by this engine.
 * @param <S> The type of {@link Strategy} which is generated by this engine.
 * @author Rimon Oz
 */
@Slf4j
public abstract class ControllerEngine<
    A extends Agent,
    S extends Strategy> implements Engine<S, Map<Integer, ControllerState>, Integer> {

  /**
   * The Controllers.
   */
  protected final ControllerManager controllers;

  @Getter
  private final Subscriber<S> strategySubscriber;

  /**
   * The publisher on which controller states are being published.
   */
  @Getter
  private final Publisher<Map<Integer, ControllerState>> controllerStatePublisher;

  public abstract Map<Integer, Set<A>> getControllerMapping();

  /**
   * Instantiates a new ControllerEngine.
   *
   * @param strategySubscriber The {@link Subscriber} which parses the {@link Strategy strategies}.
   * @param controllerCount    The number of controllers.
   */
  public ControllerEngine(final Subscriber<S> strategySubscriber, final int controllerCount) {
    this.strategySubscriber = strategySubscriber;
    this.controllers = new ControllerManager(controllerCount);
    this.controllers.initSDLGamepad();
    this.controllerStatePublisher = Flux.create(fluxSink -> {
      while (true) {
        fluxSink.next(IntStream.range(0, controllerCount)
            .boxed()
            .filter(controllerIndex -> this.controllers.getControllerIndex(controllerIndex)
                .isConnected())
            .collect(Collectors.toMap(
                Function.identity(),
                controllers::getState)));
      }
    });
  }

  /**
   * Returns a set of players which are controlled by this engine.
   *
   * @return the controlled players
   */
  public abstract Set<A> getControllableAgents();

  /**
   * Assigns the supplied handler to the supplied {@link Agent}.
   *
   * @param handler The handler to link to a {@link Agent}.
   * @param agent   The {@link Agent} to link the handler to.
   * @return set set
   */
  public Set<A> assignHandler(final Integer handler, final A agent) {
    log.info("Assigning handler '{}' to {} with identifier {}",
        handler, agent.getClass().getTypeName(), agent.getId());
    return this.getControllerMapping().put(handler, ImmutableSet.<A>builder()
        .addAll(Collections.singleton(agent))
        .addAll(this.getControllerMapping().getOrDefault(handler, Collections.emptySet())).build());
  }

  /**
   * Unassigns a handler from the specified {@link Agent}.
   *
   * @param handler The handler to unassign from the {@link Agent}.
   * @param agent   The {@link Agent} to unassign the handler from.
   * @return set set
   */
  public Set<A> unassignHandler(final Integer handler, final A agent) {
    log.info("Unassigning handler '{}' from {} with identifier {}",
        handler, agent.getClass().getTypeName(), agent.getId());
    if (this.getControllerMapping().containsKey(handler)) {
      if (this.getControllerMapping().get(handler).contains(agent)) {
        return this.getControllerMapping().put(
            handler,
            this.getControllerMapping().get(handler).stream()
                .filter(registeredAgent -> !registeredAgent.equals(agent))
                .collect(Collectors.toSet()));
      }
    }
    return Collections.emptySet();
  }

  @Override
  public void play() {
    Flux.from(this.getControllerStatePublisher())
        .subscribeOn(Schedulers.single())
        .transform(this::apply)
        .subscribe(this.getStrategySubscriber());
  }

  /**
   * Creates a {@link Strategy} from the specified command for the specified agent.
   *
   * @param agent   The {@link Agent} to create a strategy for.
   * @param command The {@link Command} to create the strategy from.
   * @return A strategy for the supplied {@link Agent} created from the supplied {@link Command}
   */
  public abstract S createStrategy(final A agent, final ControllerState command);

  @Override
  public Publisher<S> apply(
      final Publisher<Map<Integer, ControllerState>> mapPublisher
  ) {
    return Flux.from(mapPublisher)
        .map(mapping -> mapping.entrySet().stream()
        .filter(entry -> this.getControllerMapping().containsKey(entry.getKey()))
        .flatMap(entry -> this.getControllerMapping().get(entry.getKey()).stream()
            .collect(Collectors.toMap(a -> a, a -> entry))
            .entrySet().stream())
        .collect(Collectors.toMap(
            entry -> entry.getValue().getKey(),
            entry -> this.createStrategy(entry.getKey(), entry.getValue().getValue()))))
        .map(this::arbitrate);
  }
}
